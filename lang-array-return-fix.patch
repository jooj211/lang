--- a/src/interpreter/Interpreter.cpp
+++ b/src/interpreter/Interpreter.cpp
@@ -411,7 +411,7 @@
     else if (auto fv = dynamic_cast<FloatValue*>(__rv)) { last_value = new FloatValue(fv->value); value_pool.push_back(last_value); }
     else if (auto bv = dynamic_cast<BoolValue*>(__rv)) { last_value = new BoolValue(bv->value); value_pool.push_back(last_value); }
     else if (auto cv = dynamic_cast<CharValue*>(__rv)) { last_value = new CharValue(cv->value); value_pool.push_back(last_value); }
-    else { last_value = __rv; value_pool.push_back(last_value); }
+    else { last_value = __rv; /* reuse existing heap object; don't push again */ }
 } while(0);
                 }
                 else
--- a/src/typecheck/TypeChecker.cpp
+++ b/src/typecheck/TypeChecker.cpp
@@ -630,13 +630,13 @@
         if (dim)
         {
             dim->accept(this);
-            // (antes não validava ou validava pouco)
+            if (!last_inferred_type || last_inferred_type->to_string() != "Int")
+                throw std::runtime_error("Erro de Tipo: Tamanho de array deve ser Int.");
         }
         ty = std::make_shared<ArrayType>(ty);
     }
     last_inferred_type = ty;
 }
-
 void TypeChecker::visit(FieldAccessNode *node)
 {
     /* avalia o tipo da expressão antes do ponto --------------- */
