diff --git a/instances/semantica/certo/full/AFD.lan b/instances/semantica/certo/full/AFD.lan
index 78b3f43..06b0efa 100644
--- a/instances/semantica/certo/full/AFD.lan
+++ b/instances/semantica/certo/full/AFD.lan
@@ -21,20 +21,20 @@ mkAutomata(numStates :: Int):AFD{
    return m;
 }
 
-setFinal(m :: ADF, st :: Int){
+setFinal(m :: AFD, st :: Int){
     m.numt[st] = 0 - m.numt[st];
 }
 
-isFinal(m :: ADF, st :: Int): Bool{
+isFinal(m :: AFD, st :: Int): Bool{
     return  m.numt[st] < 0;
 }
 
-setNumTransitions(m :: ADF, st :: Int, n :: Int){
+setNumTransitions(m :: AFD, st :: Int, n :: Int){
     m.st[st] = new Transition[n];
     m.numt[st] = n+1;
 }
 
-addTransition(m :: ADF, st :: Int, a :: Char, d :: Int){
+addTransition(m :: AFD, st :: Int, a :: Char, d :: Int){
     i = 0;
     add = true;
     iterate(abs(m.numt[st])[0]-1){
diff --git a/new_test.sh b/new_test.sh
old mode 100755
new mode 100644
diff --git a/output.txt b/output.txt
index 1308e53..2a124be 100644
--- a/output.txt
+++ b/output.txt
@@ -15732,4 +15732,5 @@ Entering state 3
 Stack now 0 1 3
 Stack now 0 1 3
 Cleanup: popping token "end of file" ()
-Cleanup: popping nterm program ()
\ No newline at end of file
+Cleanup: popping nterm program ()
+./run_all_tests.sh, linha 39:  8910 Falha de segmentação  (imagem do núcleo gravada) "$COMPILER_EXEC" --debug -i "$test_file"
diff --git a/run_interpreter.tests.sh b/run_interpreter.tests.sh
old mode 100755
new mode 100644
diff --git a/run_parser_tests.sh b/run_parser_tests.sh
old mode 100755
new mode 100644
diff --git a/run_tests.sh b/run_tests.sh
old mode 100755
new mode 100644
diff --git a/src/interpreter/Interpreter.cpp b/src/interpreter/Interpreter.cpp
index 6bce3d6..5219d2c 100644
--- a/src/interpreter/Interpreter.cpp
+++ b/src/interpreter/Interpreter.cpp
@@ -7,6 +7,7 @@
 #include <cstdio>
 #include <typeinfo>
 #include <sstream>
+//#define INTERP_TRACE 0
 // [PATCH] Helper: clone primitive values to avoid aliasing when assigning/returning
 static Value* clone_primitive_or_self(Value* v){
     if(auto iv = dynamic_cast<IntValue*>(v))   return new IntValue(iv->value);
@@ -28,11 +29,14 @@ static const char* vname(Value* v){
     return "Value";
 }
 
-#ifdef INTERP_TRACE
+/*#ifdef INTERP_TRACE
   #define TRACE(msg) do { std::cerr << "[TRACE] " << msg << "\n"; } while(0)
 #else
   #define TRACE(msg) do { } while(0)
-#endif
+#endif */
+
+#define TRACE(msg) do { } while(0)
+
 
 Value *Interpreter::create_default_value(TypeNode *type)
 {
@@ -78,7 +82,7 @@ Value *Interpreter::create_default_value(TypeNode *type, std::set<std::string> &
         // ==================================================================
         // ====> COLOQUE A MENSAGEM DE DEBUG EXATAMENTE AQUI <====
         // ==================================================================
-        std::cerr << "[DEBUG] Tentando criar valor padrão para o tipo de registro: '" << type_name << "'.\n";
+//         std::cerr << "[DEBUG] Tentando criar valor padrão para o tipo de registro: '" << type_name << "'.\n";
 
         // VERIFICAÇÃO DE RECURSÃO
         if (visited_records.count(type_name))
@@ -385,7 +389,7 @@ void Interpreter::visit(FunCallNode *node)
     push_scope();
     for (size_t i = 0; i < func_def->params.size(); ++i)
     {
-        set_variable(func_def->params[i].name, evaluated_args[i], true);
+        set_variable(func_def->params[i].name, clone_primitive_or_self(evaluated_args[i]), true);
     }
     try
     {
@@ -394,20 +398,23 @@ void Interpreter::visit(FunCallNode *node)
     }
     catch (const ReturnSignal &ret)
     {
+
+TRACE("ReturnSignal caught");
+
         if (!ret.values.empty())
         {
-            node->return_index->accept(this);
+            TRACE("before index accept"); node->return_index->accept(this); TRACE("after index accept");
             if (auto idx_val = dynamic_cast<IntValue *>(last_value))
             {
                 if (idx_val->value >= 0 && idx_val->value < ret.values.size())
                 {
-                    do { Value* __rv = ret.values[idx_val->value];
-    if (auto iv = dynamic_cast<IntValue*>(__rv)) last_value = new IntValue(iv->value);
-    else if (auto fv = dynamic_cast<FloatValue*>(__rv)) last_value = new FloatValue(fv->value);
-    else if (auto bv = dynamic_cast<BoolValue*>(__rv)) last_value = new BoolValue(bv->value);
-    else if (auto cv = dynamic_cast<CharValue*>(__rv)) last_value = new CharValue(cv->value);
-    else last_value = __rv;
-    value_pool.push_back(last_value);
+                    do {
+    Value* __rv = ret.values[idx_val->value];
+    if (auto iv = dynamic_cast<IntValue*>(__rv)) { last_value = new IntValue(iv->value); value_pool.push_back(last_value); }
+    else if (auto fv = dynamic_cast<FloatValue*>(__rv)) { last_value = new FloatValue(fv->value); value_pool.push_back(last_value); }
+    else if (auto bv = dynamic_cast<BoolValue*>(__rv)) { last_value = new BoolValue(bv->value); value_pool.push_back(last_value); }
+    else if (auto cv = dynamic_cast<CharValue*>(__rv)) { last_value = new CharValue(cv->value); value_pool.push_back(last_value); }
+    else { last_value = __rv; /* reuse existing heap object; don't push again */ }
 } while(0);
                 }
                 else
@@ -424,7 +431,9 @@ void Interpreter::visit(FunCallNode *node)
         {
             last_value = nullptr;
         }
-    }
+
+
+}
     pop_scope();
 }
 
@@ -449,10 +458,9 @@ void Interpreter::visit(FunCallCmdNode *node)
     }
 
     push_scope();
-    for (std::size_t i = 0; i < func_def->params.size(); ++i)
-    {
-        set_variable(func_def->params[i].name, evaluated_args[i], true);
-    }
+    for (std::size_t i = 0; i < func_def->params.size(); ++i) {
+    memory_stack.back()[func_def->params[i].name] = clone_primitive_or_self(evaluated_args[i]);
+}
 
     std::vector<Value*> retvals;
     bool did_return = false;
@@ -488,10 +496,10 @@ void Interpreter::visit(FunCallCmdNode *node)
             }
             else
             {
-                set_variable("__tmp_ret", retvals[i], true);
-                AssignCmdNode tmp(node->lvalues[i], new VarAccessNode("__tmp_ret"));
+                set_variable(std::string("__tmp_ret"), retvals[i], true);
+                AssignCmdNode tmp(node->lvalues[i], new VarAccessNode(strdup("__tmp_ret")));
                 this->visit(&tmp);
-                memory_stack.back().erase("__tmp_ret");
+                memory_stack.back().erase(std::string("__tmp_ret"));
             }
         }
     }
@@ -535,11 +543,16 @@ void Interpreter::visit(ReturnCmdNode *node)
 void Interpreter::visit(BlockCmdNode *node)
 {
     push_scope();
-    for (Command *cmd : node->commands)
+    try {
+for (Command *cmd : node->commands)
     {
         cmd->accept(this);
     }
     pop_scope();
+} catch (const ReturnSignal &ret) {
+    pop_scope();
+    throw;
+}
 }
 
 void Interpreter::visit(VarDeclNode *node)
@@ -629,24 +642,22 @@ void Interpreter::visit(AssignCmdNode *node)
     // --- CASO 1: Atribuição a uma variável simples (ex: x = 10) ---
     if (auto *va = dynamic_cast<VarAccessNode *>(node->lvalue))
     {
-        // [PATCH] evaluate RHS once
-        node->expr->accept(this);
-        Value *rhs_value = last_value;
-
-        // [PATCH] if not in current scope, create local variable (shadow outer), cloning primitives
-        bool in_current_scope = (!memory_stack.empty() && memory_stack.back().count(va->name) > 0);
-        if (!in_current_scope)
+                // Look up variable anywhere in scope chain
+        Value *existing = get_variable(va->name);
+        if (existing == nullptr)
         {
+            // Declare in current scope
             if (auto iv = dynamic_cast<IntValue*>(rhs_value))       set_variable(va->name, new IntValue(iv->value), true);
             else if (auto fv = dynamic_cast<FloatValue*>(rhs_value)) set_variable(va->name, new FloatValue(fv->value), true);
             else if (auto bv = dynamic_cast<BoolValue*>(rhs_value))  set_variable(va->name, new BoolValue(bv->value), true);
             else if (auto cv = dynamic_cast<CharValue*>(rhs_value))  set_variable(va->name, new CharValue(cv->value), true);
             else                                                     set_variable(va->name, rhs_value, true);
-            return;
         }
-
-        // [PATCH] otherwise update in innermost scope
-        update_variable(va->name, rhs_value);
+        else
+        {
+            // Update existing (mutate primitive values in place)
+            update_variable(va->name, rhs_value);
+        }
         return;
     }
 
@@ -789,8 +800,7 @@ void Interpreter::visit(IterateCmdNode *node)
     if (hlv)
         pop_scope();
 }
-void Interpreter::visit(IntLiteral *node)
-{
+void Interpreter::visit(IntLiteral *node){ TRACE(std::string("IntLiteral ")+std::to_string(node->value));
     last_value = new IntValue(node->value);
     value_pool.push_back(last_value);
 }
@@ -799,8 +809,7 @@ void Interpreter::visit(FloatLiteralNode *node)
     last_value = new FloatValue(node->value);
     value_pool.push_back(last_value);
 }
-void Interpreter::visit(CharLiteralNode *node)
-{
+void Interpreter::visit(CharLiteralNode *node){ TRACE(std::string("CharLiteral ")+(char)node->value);
     last_value = new CharValue(node->value);
     value_pool.push_back(last_value);
 }
diff --git a/src/lexer/lexer.l b/src/lexer/lexer.l
index c01daf8..232c159 100644
--- a/src/lexer/lexer.l
+++ b/src/lexer/lexer.l
@@ -37,8 +37,24 @@ void yyerror(const char* s);
 
 [0-9]+\.[0-9]+ { RESET(); yylval.fval = atof(yytext); return T_FLOAT_LITERAL; }
 [0-9]+         { RESET(); yylval.ival = atoi(yytext); return T_INT_LITERAL; }
-'([^'\\]|\\.)' { RESET(); yylval.cval = yytext[1];    return T_CHAR_LITERAL; }
-
+'([^'\\]|\\.)' {
+    RESET();
+    char c = yytext[1];
+    if (c == '\\') {
+        char e = yytext[2];
+        switch (e) {
+            case 'n':  c = '\n'; break;
+            case 't':  c = '\t'; break;
+            case 'r':  c = '\r'; break;
+            case '\\': c = '\\'; break;
+            case '\'': c = '\''; break;
+            case '0':  c = '\0'; break;
+            default:   c = e;    break; // qualquer outro \x vira 'x'
+        }
+    }
+    yylval.cval = c;
+    return T_CHAR_LITERAL;
+}
 "::"   { RESET(); return T_COLON_COLON; }
 "&&"   { RESET(); return T_AND; }
 "=="   { RESET(); return T_EQ; }
diff --git a/src/typecheck/TypeChecker.cpp b/src/typecheck/TypeChecker.cpp
index e9d6fad..b19613e 100644
--- a/src/typecheck/TypeChecker.cpp
+++ b/src/typecheck/TypeChecker.cpp
@@ -6,7 +6,9 @@
 #include <iostream>
 
 #ifndef TCTRACE
-  #define TCTRACE(msg) do { std::cerr << "[TC] " << msg << "\n"; } while(0)
+  //#define TCTRACE(msg) do { std::cerr << "[TC] " << msg << "\n"; } while(0)
+  #define TCTRACE(msg) do { } while(0)
+
 #endif
 
 /* =============================================================
@@ -111,60 +113,68 @@ void TypeChecker::check(ProgramNode *ast)
 
 void TypeChecker::visit(ProgramNode *node)
 {
-    // --- PASSO 1: Registrar Nomes de Tipos ---
-    // Passamos uma vez por todas as definições de 'data' para registrar apenas
-    // seus nomes. Isso resolve o problema de recursão.
+    // PASSO 1: Registrar nomes de tipos (data)
     for (Node *def : node->definitions)
     {
         if (auto data_def = dynamic_cast<DataDefNode *>(def))
         {
-            if (record_types.count(data_def->name))
-            {
-                throw std::runtime_error("Erro Semântico: Tipo '" + data_def->name + "' já definido.");
-            }
-            // Adiciona um tipo de registro "vazio" ao mapa, apenas com o nome.
-            record_types[data_def->name] = std::make_shared<RecordType>(data_def->name);
+            if (!record_types.count(data_def->name))
+                record_types[data_def->name] = std::make_shared<RecordType>(data_def->name);
         }
     }
 
-    // --- PASSO 2: Preencher os Campos dos Tipos ---
-    // Agora que todos os nomes de tipos são conhecidos, passamos novamente para
-    // analisar e preencher os campos de cada registro.
+    // PASSO 2: Preencher campos dos tipos (data)
     for (Node *def : node->definitions)
     {
         if (auto data_def = dynamic_cast<DataDefNode *>(def))
-        {
-            data_def->accept(this); // Chama o novo visit(DataDefNode*)
-        }
+            data_def->accept(this);
     }
 
-    // --- PASSO 3: Registrar Assinaturas de Funções ---
-    // A análise das funções só ocorre após todos os tipos estarem definidos.
+    // PASSO 3: Registrar assinaturas das funções (params/returns)
     for (Node *def : node->definitions)
     {
         if (auto fun_def = dynamic_cast<FunDefNode *>(def))
         {
-            fun_def->accept(this);
+            auto f = std::make_shared<FunctionType>();
+            for (auto &p : fun_def->params)  f->param_types.push_back(type_from_node(p.type));
+            for (auto *r : fun_def->return_types) f->return_types.push_back(type_from_node(r));
+            if (function_types.count(fun_def->name))
+                throw std::runtime_error("Erro Semântico: Função '" + fun_def->name + "' já definida.");
+            function_types[fun_def->name] = f;
         }
     }
 
-    // --- PASSO 4: Verificar os Corpos das Funções ---
+    // PASSO 4: Checar corpos das funções com current_function_type e params no escopo
     for (Node *def : node->definitions)
     {
         if (auto fun_def = dynamic_cast<FunDefNode *>(def))
         {
-            current_function_type = function_types[fun_def->name];
+            current_function_type = function_types.at(fun_def->name);
             push_scope();
-            for (const auto &param : fun_def->params)
-            {
-                add_variable(param.name, type_from_node(param.type));
-            }
+            for (auto &p : fun_def->params)
+                add_variable(p.name, type_from_node(p.type));
             fun_def->body->accept(this);
             pop_scope();
+            current_function_type.reset();
+        }
+    }
+
+    // DEBUG: print function signatures
+    for (auto &kv : function_types) {
+        std::stringstream ss;
+        ss << "fun " << kv.first << " returns [";
+        for (size_t i=0;i<kv.second->return_types.size();++i){
+            if (kv.second->return_types[i]) ss << kv.second->return_types[i]->to_string();
+            else ss << "<null>";
+            if (i+1<kv.second->return_types.size()) ss << ", ";
         }
+        ss << "]";
+        TCTRACE(ss.str());
     }
 }
 
+
+
 void TypeChecker::visit(DataDefNode *node)
 {
     // 1. O tipo já foi pré-registrado, então o recuperamos do mapa.
@@ -219,6 +229,8 @@ void TypeChecker::visit(VarDeclNode *node)
 
 void TypeChecker::visit(AssignCmdNode *node)
 {
+    TCTRACE("visit AssignCmdNode");
+
     /* 1. Verifica se é um lvalue simples (acesso a variável, ex: x = ...) */
     if (auto *va = dynamic_cast<VarAccessNode *>(node->lvalue))
     {
@@ -230,10 +242,11 @@ void TypeChecker::visit(AssignCmdNode *node)
 
         /* ── b) Avalia o tipo do lado direito (RHS) da atribuição. */
         node->expr->accept(this);
-        auto rhs_type = last_inferred_type;
+        auto rhs_type = last_inferred_type; if(rhs_type) { std::stringstream ss; ss<<"RHS="<<rhs_type->to_string(); TCTRACE(ss.str()); } else { TCTRACE("RHS=<null>"); }
 
         /* ── c) Obtém o tipo do lado esquerdo (LHS) que já está no contexto. */
         auto lhs_type = get_variable_type(va->name);
+        if(lhs_type){ std::stringstream ss; ss<<"LHS(var)="<<lhs_type->to_string(); TCTRACE(ss.str()); } else { TCTRACE("LHS(var)=<null>"); }
 
         /* ── d) Se o tipo do LHS é 'Unknown', realiza a unificação. */
         if (lhs_type->is_unknown())
@@ -264,10 +277,10 @@ void TypeChecker::visit(AssignCmdNode *node)
 
     /* 2. Lida com lvalues mais complexos (ex: p.x = ..., arr[i] = ...) */
     node->lvalue->accept(this);
-    auto lhs_type = last_inferred_type;
+    auto lhs_type = last_inferred_type; if(lhs_type) { std::stringstream ss2; ss2<<"LHS="<<lhs_type->to_string(); TCTRACE(ss2.str()); } else { TCTRACE("LHS=<null>"); }
 
     node->expr->accept(this);
-    auto rhs_type = last_inferred_type;
+    auto rhs_type = last_inferred_type; if(rhs_type) { std::stringstream ss; ss<<"RHS="<<rhs_type->to_string(); TCTRACE(ss.str()); } else { TCTRACE("RHS=<null>"); }
 
     // Permite atribuir `null` a qualquer tipo não primitivo.
     if (rhs_type->is_null() && !lhs_type->is_primitive())
@@ -539,6 +552,8 @@ void TypeChecker::visit(FunCallCmdNode *n)
 
 void TypeChecker::visit(ReturnCmdNode *n)
 {
+    TCTRACE("visit ReturnCmdNode");
+
     if (!current_function_type)
         throw std::runtime_error("'return' fora de função.");
 
@@ -551,14 +566,19 @@ void TypeChecker::visit(ReturnCmdNode *n)
         auto expr = last_inferred_type;
         auto expected = current_function_type->return_types[i];
 
-        if (expected->is_unknown())
-            *expected = *expr;
+        if (!expr || !expected)
+            throw std::runtime_error("Erro de Tipo interno em 'return'.");
+
+        if (expected->is_unknown())            *expected = *expr;
+        else if (expr->is_unknown())           *expr = *expected;
         else if (expr->is_null() && !expected->is_primitive())
-            continue;
+            continue; // permitir null para tipos não primitivos
         else if (expr->to_string() != expected->to_string())
-            throw std::runtime_error("Tipo de retorno " + idx_str(i) + " incompatível (esperado " + expected->to_string() + ", obteve " + expr->to_string() + ").");
+            throw std::runtime_error("Tipo de retorno [" + std::to_string(i) + "] incompatível (esperado "
+                                     + expected->to_string() + ", obteve " + expr->to_string() + ").");
     }
 }
+
 void TypeChecker::visit(UnaryOpNode *node)
 {
     /* 1. Visita o operando ------------------------------------ */
@@ -606,27 +626,19 @@ void TypeChecker::visit(IterateCmdNode *node) { /* TODO */ }
 void TypeChecker::visit(NewExprNode *node)
 {
     TCTRACE("visit NewExprNode");
-
-    // 1) tipo base (ex.: Int, Transition, AFD, etc.)
-    std::shared_ptr<Type> current_type = type_from_node(node->base_type);
-
-    // 2) cada "[]" envolve o tipo em ArrayType;
-    //    se tiver expressão, ela deve ser Int; se for omitida ([]), só envolve.
-    for (auto dim_expr : node->dims)
+    std::shared_ptr<Type> ty = type_from_node(node->base_type);
+    for (Expression* dim : node->dims)
     {
-        if (dim_expr) {
-            dim_expr->accept(this);
-            if (!last_inferred_type || last_inferred_type->to_string() != "Int") {
-                throw std::runtime_error("Erro de Tipo: Dimensões de um array devem ser do tipo Int.");
-            }
+        if (dim)
+        {
+            dim->accept(this);
+            if (!last_inferred_type || last_inferred_type->to_string() != "Int")
+                throw std::runtime_error("Erro de Tipo: Tamanho de array deve ser Int.");
         }
-        current_type = std::make_shared<ArrayType>(current_type);
+        ty = std::make_shared<ArrayType>(ty);
     }
-
-    last_inferred_type = current_type;
+    last_inferred_type = ty;
 }
-
-
 void TypeChecker::visit(FieldAccessNode *node)
 {
     /* avalia o tipo da expressão antes do ponto --------------- */
diff --git a/temp_parser_test.lang b/temp_parser_test.lang
deleted file mode 100644
index c0d1e81..0000000
--- a/temp_parser_test.lang
+++ /dev/null
@@ -1,20 +0,0 @@
-main(): Int {
-    idade :: Int;
-    altura :: Float;
-    aceita :: Bool;
-    inicial :: Char;
-
-    read idade;
-    print idade;
-
-    read altura;
-    print altura;
-
-    read aceita;
-    print aceita;
-
-    read inicial;
-    print inicial;
-
-    return 0;
-}
diff --git a/testes/sintaxe_certo.sh b/testes/sintaxe_certo.sh
old mode 100755
new mode 100644
diff --git a/testes/sintaxe_errado.sh b/testes/sintaxe_errado.sh
old mode 100755
new mode 100644
diff --git a/testes/types_errado.sh b/testes/types_errado.sh
old mode 100755
new mode 100644
diff --git a/testes/types_full.sh b/testes/types_full.sh
old mode 100755
new mode 100644
diff --git a/testes/types_function.sh b/testes/types_function.sh
old mode 100755
new mode 100644
