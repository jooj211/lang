--- a/src/interpreter/Interpreter.cpp
+++ b/src/interpreter/Interpreter.cpp
@@ -7,6 +7,15 @@
 #include <cstdio>
 #include <typeinfo>
 #include <sstream>
+// [PATCH] Helper: clone primitive values to avoid aliasing when assigning/returning
+static Value* clone_primitive_or_self(Value* v){
+    if(auto iv = dynamic_cast<IntValue*>(v))   return new IntValue(iv->value);
+    if(auto fv = dynamic_cast<FloatValue*>(v)) return new FloatValue(fv->value);
+    if(auto bv = dynamic_cast<BoolValue*>(v))  return new BoolValue(bv->value);
+    if(auto cv = dynamic_cast<CharValue*>(v))  return new CharValue(cv->value);
+    return v;
+}
+
 
 static const char* vname(Value* v){
     if(!v) return "null";
@@ -392,7 +401,14 @@
             {
                 if (idx_val->value >= 0 && idx_val->value < ret.values.size())
                 {
-                    last_value = ret.values[idx_val->value];
+                    do { Value* __rv = ret.values[idx_val->value];
+    if (auto iv = dynamic_cast<IntValue*>(__rv)) last_value = new IntValue(iv->value);
+    else if (auto fv = dynamic_cast<FloatValue*>(__rv)) last_value = new FloatValue(fv->value);
+    else if (auto bv = dynamic_cast<BoolValue*>(__rv)) last_value = new BoolValue(bv->value);
+    else if (auto cv = dynamic_cast<CharValue*>(__rv)) last_value = new CharValue(cv->value);
+    else last_value = __rv;
+    value_pool.push_back(last_value);
+} while(0);
                 }
                 else
                 {
@@ -417,53 +433,61 @@
     TRACE(std::string("CallCmd ")+node->name);
 
     if (!functions.count(node->name))
+    {
         return;
-
+    }
     FunDefNode *func_def = functions[node->name];
-
-    // avalia argumentos
-    std::vector<Value*> evaluated_args;
-    for (Expression *arg_expr : node->args) {
+    std::vector<Value *> evaluated_args;
+    for (Expression *arg_expr : node->args)
+    {
         arg_expr->accept(this);
         evaluated_args.push_back(last_value);
     }
     if (evaluated_args.size() != func_def->params.size())
+    {
         throw std::runtime_error("Erro de Execução: Aridade incorreta na chamada de função.");
-
-    // cria frame da função
+    }
+
     push_scope();
     for (std::size_t i = 0; i < func_def->params.size(); ++i)
+    {
         set_variable(func_def->params[i].name, evaluated_args[i], true);
-
-    // executa e captura retornos
+    }
+
     std::vector<Value*> retvals;
     bool did_return = false;
-    try {
+    try
+    {
         func_def->body->accept(this);
-    } catch (const ReturnSignal &ret) {
+    }
+    catch (const ReturnSignal &ret)
+    {
         retvals = ret.values;
         did_return = true;
     }
-
-    // sai do escopo da função antes de tocar nos lvalues do chamador
     pop_scope();
 
-    if (did_return && node->lvalues.size() == retvals.size()) {
-        for (size_t i = 0; i < node->lvalues.size(); ++i) {
-            if (auto var_access = dynamic_cast<VarAccessNode *>(node->lvalues[i])) {
-                // se não houver no escopo atual do chamador, declara; senão atualiza
-                if (get_variable(var_access->name) == nullptr || (memory_stack.back().count(var_access->name) == 0)) {
-                    // cópia para primitivos evita aliasing
+    if (did_return && node->lvalues.size() > 0 && node->lvalues.size() == retvals.size())
+    {
+        for (size_t i = 0; i < node->lvalues.size(); ++i)
+        {
+            if (auto var_access = dynamic_cast<VarAccessNode *>(node->lvalues[i]))
+            {
+                if (get_variable(var_access->name) == nullptr || (memory_stack.back().count(var_access->name) == 0))
+                {
                     if (auto iv = dynamic_cast<IntValue*>(retvals[i]))       set_variable(var_access->name, new IntValue(iv->value), true);
                     else if (auto fv = dynamic_cast<FloatValue*>(retvals[i])) set_variable(var_access->name, new FloatValue(fv->value), true);
                     else if (auto bv = dynamic_cast<BoolValue*>(retvals[i]))  set_variable(var_access->name, new BoolValue(bv->value), true);
                     else if (auto cv = dynamic_cast<CharValue*>(retvals[i]))  set_variable(var_access->name, new CharValue(cv->value), true);
                     else                                                       set_variable(var_access->name, retvals[i], true);
-                } else {
+                }
+                else
+                {
                     update_variable(var_access->name, retvals[i]);
                 }
-            } else {
-                // lvalue composto: usa AssignCmdNode com temp
+            }
+            else
+            {
                 set_variable("__tmp_ret", retvals[i], true);
                 AssignCmdNode tmp(node->lvalues[i], new VarAccessNode("__tmp_ret"));
                 this->visit(&tmp);
@@ -472,6 +496,7 @@
         }
     }
 }
+
 
 
 void Interpreter::visit(FieldAccessNode *node)
@@ -604,15 +629,14 @@
     // --- CASO 1: Atribuição a uma variável simples (ex: x = 10) ---
     if (auto *va = dynamic_cast<VarAccessNode *>(node->lvalue))
     {
-        // avalia RHS
+        // [PATCH] evaluate RHS once
         node->expr->accept(this);
         Value *rhs_value = last_value;
 
-        // se NÃO existe no escopo atual, cria variável local
+        // [PATCH] if not in current scope, create local variable (shadow outer), cloning primitives
         bool in_current_scope = (!memory_stack.empty() && memory_stack.back().count(va->name) > 0);
         if (!in_current_scope)
         {
-            // copia primitivos para evitar aliasing
             if (auto iv = dynamic_cast<IntValue*>(rhs_value))       set_variable(va->name, new IntValue(iv->value), true);
             else if (auto fv = dynamic_cast<FloatValue*>(rhs_value)) set_variable(va->name, new FloatValue(fv->value), true);
             else if (auto bv = dynamic_cast<BoolValue*>(rhs_value))  set_variable(va->name, new BoolValue(bv->value), true);
@@ -621,7 +645,7 @@
             return;
         }
 
-        // caso contrário, atualiza a existente
+        // [PATCH] otherwise update in innermost scope
         update_variable(va->name, rhs_value);
         return;
     }
--- a/src/typecheck/TypeChecker.cpp
+++ b/src/typecheck/TypeChecker.cpp
@@ -501,11 +501,11 @@
             *param = *arg;
         else if (arg->is_unknown())
             *arg = *param;
-        else if (arg->to_string() != param->to_string())
-            throw std::runtime_error("Tipo do argumento " + idx_str(i) + " incompatível na chamada de '" + n->name + "'.");
-    }
-
-    // ----- captura -----
+        else if (param->to_string() != arg->to_string())
+            throw std::runtime_error("Tipo de argumento incompatível na chamada de '" + n->name + "'.");
+    }
+
+    // ----- lvalues -----
     if (n->lvalues.size() != f->return_types.size())
         throw std::runtime_error("Aridade de retorno incorreta na chamada de '" + n->name + "'.");
 
@@ -513,17 +513,18 @@
     {
         auto rhs = f->return_types[i];
 
-        // se for um identificador e não existir, declara no escopo atual
+        // se lvalue é identificador não declarado, declara implicitamente
         if (auto var_acc = dynamic_cast<VarAccessNode*>(n->lvalues[i]))
         {
             auto existing = get_variable_type(var_acc->name);
             if (!existing)
             {
                 add_variable(var_acc->name, rhs);
-                continue; // já resolveu este lvalue
+                continue;
             }
         }
-        // checagem padrão para lvalues já existentes (ou acessos compostos)
+
+        // checagem padrão para lvalues existentes (ou acessos compostos)
         n->lvalues[i]->accept(this);
         auto lhs = last_inferred_type;
 
@@ -535,6 +536,7 @@
             throw std::runtime_error("Tipo incompatível ao capturar retorno [" + std::to_string(i) + "] de '" + n->name + "'.");
     }
 }
+
 void TypeChecker::visit(ReturnCmdNode *n)
 {
     if (!current_function_type)
